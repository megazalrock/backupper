---
paths: **/*.{ts,vue}
---

# コーディング原則

## DRY（Don't Repeat Yourself）

重複コードを特定し、共通化・抽象化を提案

同じロジックが複数箇所に存在すると、修正漏れやバグの温床となる。共通のバリデーション、データ変換、API呼び出しパターンなどは`composables/`や`utils/`に切り出し、一元管理することで保守性を高める。

## KISS（Keep It Short and Simple）

過度に複雑な実装を指摘し、シンプルな代替案を提示

複雑な条件分岐やネストの深いコードは可読性を損なう。早期リターン、ガード節、適切な関数分割を活用し、1つの関数は20〜30行以内に収めることを目指す。読み手が一目で意図を理解できるコードが理想である。

## SOLID原則（フロントエンド調整版）:

### 単一責任の原則

コンポーネントや関数は1つの責任のみを持つべきである。表示ロジック、ビジネスロジック、データ取得は分離し、「このコードは何をするものか」を一言で説明できる粒度に保つ。

### 開放閉鎖の原則

拡張に対して開き、修正に対して閉じる設計を心がける。propsやslotを活用し、既存コードを変更せずに新機能を追加できる柔軟な設計を目指す。

### 依存性逆転の原則

具体的な実装ではなく抽象（インターフェース）に依存させる。APIクライアントやストアへの直接依存を避け、composablesを介して注入することでテスタビリティと柔軟性を確保する。

## YAGNI（You Aren't Gonna Need It）

現在不要な機能や過剰な抽象化を指摘

「将来使うかもしれない」という理由での実装は避ける。未使用のパラメータ、過度に汎用化されたユーティリティ、使われない設定オプションはコードの複雑さを増すだけである。必要になった時点で実装する方が、実際の要件に即した設計ができる。

## Composition Over Inheritance

Vue 3のComposition APIを活用し、継承より構成を推奨

継承は密結合を生み、変更の影響範囲が予測しにくくなる。composablesで機能を小さな単位に分割し、必要な機能だけを組み合わせることで、再利用性と保守性を両立させる。mixinsよりcomposablesを選択する。